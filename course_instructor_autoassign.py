# -*- coding: utf-8 -*-
"""
Created on Fri Sep 26 10:42:46 2025

@author: ekawa
"""

# -*- coding: utf-8 -*-
"""โปรแกรมจัดการวิชาและผู้สอนอัตโนมัติ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GnBsK9PypsZ-KlYf-nFimtnc7U_Zn1U
"""

import pandas as pd
import numpy as np
import random
from tqdm import tqdm
import copy
from multiprocessing import Pool, cpu_count

# --- 1. การสร้างข้อมูลตัวอย่าง ---
def create_sample_data(num_courses=50, num_instructors=20):
    """สร้างข้อมูลตัวอย่างสำหรับรายวิชาและอาจารย์"""
    # ข้อมูลวิชา
    # Generate unique course IDs first
    course_ids = set()
    while len(course_ids) < num_courses:
        course_ids.add(f'SCMA{random.randint(100, 499)}')
    course_ids = list(course_ids)

    course_data = {
        'courseID': course_ids,
        'courseCredit': [random.randint(1, 4) for _ in range(num_courses)],
        'year': [random.randint(1, 4) for _ in range(num_courses)],
        'semester': [random.randint(1, 2) for _ in range(num_courses)],
        'courseType': [random.choices([0, 1, 2], weights=[0.2, 0.5, 0.3])[0] for _ in range(num_courses)]
    }
    courses_df = pd.DataFrame(course_data)

    # ทำให้มีวิชาบังคับในปีและเทอมเดียวกันเพื่อทดสอบ FN2
    # Ensure these indices exist and are within bounds
    if num_courses >= 2:
        courses_df.loc[0, ['year', 'semester', 'courseType']] = [1, 1, 1]
        courses_df.loc[1, ['year', 'semester', 'courseType']] = [1, 1, 1]


    # ข้อมูลอาจารย์
    instructor_data = {
        'InstructorID': list(range(num_instructors)),
        'name': [f'Instructor_{i}' for i in range(num_instructors)],
        'personalCredit': [random.randint(6, 12) for _ in range(num_instructors)]
    }
    instructors_df = pd.DataFrame(instructor_data)

    # Adjust personalCredit to match total courseCredit
    total_course_credit = courses_df['courseCredit'].sum()
    total_personal_credit = instructors_df['personalCredit'].sum()
    credit_difference = total_course_credit - total_personal_credit

    # Calculate average difference per instructor
    if num_instructors > 0:
        avg_difference_per_instructor = credit_difference / num_instructors
        # Add the average difference to each instructor's personalCredit
        instructors_df['personalCredit'] = instructors_df['personalCredit'] + avg_difference_per_instructor
        # Ensure personalCredit is integer and non-negative
        #instructors_df['personalCredit'] = instructors_df['personalCredit'].round().astype(int)
        instructors_df['personalCredit'] = instructors_df['personalCredit'].apply(lambda x: max(0, x))


    # สร้าง preference scores
    pref_matrix = np.zeros((num_instructors, num_courses), dtype=int)
    for i in range(num_instructors):
        num_prefs = random.randint(50, 70)
        # Ensure course_indices are within the valid range for the generated courses
        course_indices = random.sample(range(num_courses), num_prefs)
        scores = random.choices([1, -1], k=num_prefs)
        for j, score in zip(course_indices, scores):
            pref_matrix[i, j] = score

    # Ensure the columns match the generated course IDs
    pref_df = pd.DataFrame(pref_matrix, columns=courses_df['courseID'].values)
    instructors_df = pd.concat([instructors_df, pref_df], axis=1)

    return courses_df, instructors_df

# --- ฟังก์ชันสำหรับ Report ที่เรียกใช้ในแต่ละ Generation ---
def report_generation_stats(best_chromosome, generation_number, best_fitness, courses_df, instructors_df):
    """คำนวณและรายงานค่าสถิติสำคัญสำหรับ chromosome ที่ดีที่สุดของ generation นั้นๆ"""
    num_instructors = len(instructors_df)
    course_ids = courses_df['courseID'].values

    wanted_courses_counts = [0] * num_instructors
    unwanted_courses_assigned_total = 0
    assigned_credits = [0] * num_instructors # Initialize assigned_credits

    for course_idx, instructor_idx in enumerate(best_chromosome):
        # Ensure course_idx is within the bounds of courses_df
        if course_idx < len(courses_df):
            course_id = course_ids[course_idx]
            # Ensure instructor_idx is within the bounds of instructors_df
            if instructor_idx < len(instructors_df):
                 # Ensure course_id exists as a column in instructors_df
                if course_id in instructors_df.columns:
                    original_preference = instructors_df.loc[instructor_idx, course_id]

                    if original_preference == 1:
                        wanted_courses_counts[instructor_idx] += 1
                    elif original_preference == -1:
                        unwanted_courses_assigned_total += 1

                    # Add credit for reporting assigned credits
                    assigned_credits[instructor_idx] += courses_df.iloc[course_idx]['courseCredit']
                else:
                    tqdm.write(f"Warning: Course ID '{course_id}' not found in instructors_df columns.")
            else:
                tqdm.write(f"Warning: Instructor index {instructor_idx} out of bounds.")
        else:
            tqdm.write(f"Warning: Course index {course_idx} out of bounds.")


    avg_wanted_assigned = np.mean(wanted_courses_counts) if wanted_courses_counts else 0 # Handle empty list
    sd_wanted_assigned = np.std(wanted_courses_counts) if wanted_courses_counts else 0 # Handle empty list

    # Calculate number of instructors with significant credit difference
    instructors_with_credit_diff = sum(1 for i in range(num_instructors) if assigned_credits[i] - np.floor(instructors_df.loc[i, 'personalCredit']) > 1 or instructors_df.loc[i, 'personalCredit'] - assigned_credits[i] > 0.5)


    # แสดงผล
    tqdm.write(f"\n--- Generation {generation_number} Report ---")
    tqdm.write(f"Best Fitness: {best_fitness:.2f}")
    tqdm.write(f"  - ค่าเฉลี่ยจำนวนวิชาที่อาจารย์มี preference score เท่ากับ 1 และได้รับ assign ให้สอน: {avg_wanted_assigned:.4f}")
    tqdm.write(f"  - SD จำนวนวิชาที่อาจารย์มี preference score เท่ากับ 1 และได้รับ assign ให้สอน: {sd_wanted_assigned:.4f}")
    tqdm.write(f"  - ผลรวมจำนวนวิชาที่อาจารย์มี preference score เท่ากับ -1 และได้รับ assign ให้สอน: {unwanted_courses_assigned_total}")
    tqdm.write(f"  - อาจารย์ที่มี assigned credit ต่างกับ personal credit มีอยู่: {instructors_with_credit_diff} คน")


# --- 2. Genetic Algorithm ---

def calculate_fitness(chromosome, courses_df, instructors_df):
    """คำนวณค่า Fitness ของ Chromosome หนึ่งตัว (ยิ่งน้อยยิ่งดี)"""
    num_instructors = len(instructors_df)
    course_ids = courses_df['courseID'].values

    assignments = {i: [] for i in range(num_instructors)}
    assigned_credits = [0] * num_instructors # Initialize assigned_credits for FN6
    for course_idx, instructor_idx in enumerate(chromosome):
         # Ensure instructor_idx is within the bounds of assignments dictionary keys
        if instructor_idx in assignments:
            assignments[instructor_idx].append(course_idx)
            # Add credit for FN6
            if course_idx < len(courses_df):
                 assigned_credits[instructor_idx] += courses_df.iloc[course_idx]['courseCredit']
        else:
            tqdm.write(f"Warning: Instructor index {instructor_idx} not found in assignments dictionary keys.")


    # FN1
    credit_diffs_sq = []
    for i in range(num_instructors):
        # Ensure assignments[i] is not empty and indices are within courses_df bounds
        if assignments[i] and all(idx < len(courses_df) for idx in assignments[i]):
            assigned_credits_fn1 = courses_df.iloc[assignments[i]]['courseCredit'].sum()
            personal_credit = instructors_df.loc[i, 'personalCredit']
            credit_diffs_sq.append((assigned_credits_fn1 - personal_credit) ** 2)
        elif assignments[i]:
             tqdm.write(f"Warning: Indices in assignments[{i}] out of bounds for courses_df in FN1 calculation.")
        else:
             # Handle cases where an instructor has no assignments without printing a warning
             pass # No assignments for this instructor, credit_diff is just personal_credit squared
             # personal_credit = instructors_df.loc[i, 'personalCredit']
             # credit_diffs_sq.append((-personal_credit) ** 2)


    FN1 = sum(credit_diffs_sq)

    # FN2
    FN2 = 0
    for i in range(num_instructors):
        compulsory_courses_info = []
        # Ensure assignments[i] is not empty and indices are within courses_df bounds
        if assignments[i] and all(idx < len(courses_df) for idx in assignments[i]):
            for course_idx in assignments[i]:
                course_info = courses_df.iloc[course_idx]
                if course_info['courseType'] == 1:
                    compulsory_courses_info.append((course_info['year'], course_info['semester']))
            if len(compulsory_courses_info) > len(set(compulsory_courses_info)):
                FN2 = 100000
                break
        elif assignments[i]:
             tqdm.write(f"Warning: Indices in assignments[{i}] out of bounds for courses_df in FN2 calculation.")


    # FN3
    FN3 = 0
    for course_idx, instructor_idx in enumerate(chromosome):
         # Ensure course_idx is within the bounds of course_ids and instructor_idx is within the bounds of instructors_df
        if course_idx < len(course_ids) and instructor_idx < len(instructors_df):
            course_id = course_ids[course_idx]
            # Ensure course_id exists as a column in instructors_df
            if course_id in instructors_df.columns:
                preference = instructors_df.loc[instructor_idx, course_id]
                if preference == -1:
                    FN3 += 1
            else:
                tqdm.write(f"Warning: Course ID '{course_id}' not found in instructors_df columns during FN3 calculation.")
        else:
            tqdm.write(f"Warning: Course index {course_idx} or instructor index {instructor_idx} out of bounds during FN3 calculation.")


    # FN4 & FN5
    wanted_courses_counts = [0] * num_instructors
    for course_idx, instructor_idx in enumerate(chromosome):
         # Ensure course_idx is within the bounds of course_ids and instructor_idx is within the bounds of instructors_df
        if course_idx < len(course_ids) and instructor_idx < len(instructors_df):
            course_id = course_ids[course_idx]
             # Ensure course_id exists as a column in instructors_df
            if course_id in instructors_df.columns:
                preference = instructors_df.loc[instructor_idx, course_id]
                if preference == 1:
                    wanted_courses_counts[instructor_idx] += 1
            else:
                 tqdm.write(f"Warning: Course ID '{course_id}' not found in instructors_df columns during FN4/FN5 calculation.")
        else:
            tqdm.write(f"Warning: Course index {course_idx} or instructor index {instructor_idx} out of bounds during FN4/FN5 calculation.")


    FN4 = np.std(wanted_courses_counts) if wanted_courses_counts else 0 # Handle empty list
    FN5 = np.mean(wanted_courses_counts) if wanted_courses_counts else 0 # Handle empty list

    # FN6: Calculate the number of instructors with assigned_credits significantly different from personal_credit
    FN6 = 0
    for i in range(num_instructors):
        personal_credit = instructors_df.loc[i, 'personalCredit']
        if assigned_credits[i] - np.floor(personal_credit) > 1 or personal_credit - assigned_credits[i] > 0.5:
            FN6 += 1

    #FN6 *= 100


    # Fitness Function รวม
    total_fitness = FN1 + FN2 + (FN3 * 100) + (FN4 - FN5)*50 + FN6*200 + 100

    return total_fitness

def create_individual(num_courses, num_instructors):
    """สร้าง Chromosome (โซลูชัน) แบบสุ่ม 1 ตัว"""
    return [random.randint(0, num_instructors - 1) for _ in range(num_courses)]

def create_greedy_individual(courses_df, instructors_df):
    """สร้าง Chromosome แบบ Greedy โดยพยายาม assign ให้กับอาจารย์ที่มี preference score = 1"""
    num_courses = len(courses_df)
    num_instructors = len(instructors_df)
    course_ids = courses_df['courseID'].values
    chromosome = [-1] * num_courses # ใช้ -1 เป็นค่าเริ่มต้นเพื่อระบุว่ายังไม่ได้ assign

    # สร้างรายการของอาจารย์ที่มี preference score เป็น 1 สำหรับแต่ละวิชา
    preferred_instructors = {}
    for course_idx in range(num_courses):
        course_id = course_ids[course_idx]
        preferred_instructors[course_idx] = []
        # ตรวจสอบว่า course_id อยู่ใน columns ของ instructors_df หรือไม่
        if course_id in instructors_df.columns:
            for instructor_idx in range(num_instructors):
                if instructors_df.loc[instructor_idx, course_id] == 1:
                    preferred_instructors[course_idx].append(instructor_idx)
        else:
            tqdm.write(f"Warning: Course ID '{course_id}' not found in instructors_df columns during greedy individual creation.")


    # พยายาม assign ให้กับอาจารย์ที่ prefer
    for course_idx in range(num_courses):
        if preferred_instructors[course_idx]:
            # สุ่มเลือกอาจารย์จากกลุ่มที่ prefer
            chosen_instructor = random.choice(preferred_instructors[course_idx])
            chromosome[course_idx] = chosen_instructor

    # สำหรับวิชาที่ยังไม่ได้ assign (ไม่มีอาจารย์ที่ prefer หรือไม่มีวิชานั้นใน instructors_df)
    # assign แบบสุ่มให้กับอาจารย์คนใดก็ได้
    for course_idx in range(num_courses):
        if chromosome[course_idx] == -1:
            chromosome[course_idx] = random.randint(0, num_instructors - 1)

    return chromosome


def swap_mutation(chromosome):
    """กลายพันธุ์โดยการสลับตำแหน่งยีน 2 ตำแหน่ง"""

    #mutated_chromosome = chromosome[:]
    mutated_chromosome = copy.deepcopy(chromosome[:])
    # Ensure chromosome has at least 2 elements for swapping
    if len(mutated_chromosome) >= 2:
        r = random.randint(1,12)
        for i in range(r):
            idx1, idx2 = random.sample(range(len(mutated_chromosome)), 2)
            mutated_chromosome[idx1], mutated_chromosome[idx2] = mutated_chromosome[idx2], mutated_chromosome[idx1]
    return mutated_chromosome

def change_mutation(chromosome, num_instructors):
    """กลายพันธุ์โดยการเปลี่ยนค่าในยีนสุ่มหนึ่งตำแหน่ง"""
    mutated_chromosome = copy.deepcopy(chromosome[:])
    if len(mutated_chromosome) > 0:
        idx = random.randint(0, len(mutated_chromosome) - 1)
        mutated_chromosome[idx] = random.randint(0, num_instructors - 1)
    return mutated_chromosome


def crossover(parent1, parent2):
    """ทำการ Crossover แบบ One-Point ระหว่าง Chromosome 2 ตัว"""
    # Ensure parents have the same length and are not empty
    if not parent1 or len(parent1) != len(parent2):
        return copy.deepcopy(parent1), copy.deepcopy(parent2) # Return copies of original parents if invalid

    crossover_point = random.randint(1, len(parent1) - 1)

    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]

    return child1, child2


# Helper function to wrap calculate_fitness for multiprocessing
def calculate_fitness_parallel(args):
    chromosome, courses_df, instructors_df = args
    return calculate_fitness(chromosome, courses_df, instructors_df)


# --- 3. Main Execution ---
if __name__ == '__main__':
    # --- ตั้งค่าพารามิเตอร์ ---
    NUM_COURSES = 120
    NUM_INSTRUCTORS = 40
    POPULATION_SIZE = 100
    NUM_GENERATIONS = 200
    ELITE_SIZE = 3
    MUTATION_RATE = 0.5 # อัตราส่วนของ change mutation เทียบกับ swap mutation
    CHANGE_MUTATION_RATE = 0.40 # 40% change mutation
    SWAP_MUTATION_RATE = 0.40 # 40% swap mutation
    CROSSOVER_RATE = 0.20 # 20% crossover
    GREEDY_POPULATION_PERCENT = 0.80 # 80% ของประชากรเริ่มต้นเป็นแบบ Greedy

    # สร้างข้อมูล
    courses_df, instructors_df = create_sample_data(NUM_COURSES, NUM_INSTRUCTORS)
    print("--- ข้อมูลรายวิชา (5 แถวแรก) ---")
    print(courses_df.head())
    print("\n--- ข้อมูลอาจารย์ (5 แถวแรก) ---")
    print(instructors_df.head().iloc[:,:8])

    # --- เริ่ม Genetic Algorithm ---
    print("\nStarting Genetic Algorithm...")

    # 1. สร้างประชากรเริ่มต้น
    num_greedy_individuals = int(POPULATION_SIZE * GREEDY_POPULATION_PERCENT)
    population = [create_greedy_individual(courses_df, instructors_df) for _ in range(num_greedy_individuals)]
    population.extend([create_individual(NUM_COURSES, NUM_INSTRUCTORS) for _ in range(POPULATION_SIZE - num_greedy_individuals)])


    # Variable to track fitness history
    fitness_history = []
    consecutive_same_fitness = 0

    # 2. วนลูป Evolution
    # ใช้ tqdm.write เพื่อให้ print ไม่ขัดกับ progress bar
    progress_bar = tqdm(range(NUM_GENERATIONS), desc="Evolving Generations")

    # Determine the number of processes to use
    num_processes = cpu_count()
    print(f"Using {num_processes} processes for parallel fitness calculation.")

    with Pool(processes=num_processes) as pool:
        for gen in progress_bar:
            # คำนวณ fitness แบบขนาน
            fitness_scores = pool.map(calculate_fitness_parallel, [(chrom, courses_df, instructors_df) for chrom in population])

            # จับคู่ chromosome กับ fitness score แล้วเรียงลำดับ
            population_with_fitness = sorted(zip(population, fitness_scores), key=lambda x: x[1])

            # --- >> ส่วนที่ปรับปรุง: รายงานผลของ Generation ปัจจุบัน << ---
            best_chromosome_this_gen = population_with_fitness[0][0]
            best_fitness_this_gen = population_with_fitness[0][1]

            # Track fitness history and check for consecutive same fitness
            fitness_history.append(best_fitness_this_gen)
            if len(fitness_history) > 1 and fitness_history[-1] == fitness_history[-2]:
                consecutive_same_fitness += 1
            else:
                consecutive_same_fitness = 0

            # Adjust population size if fitness is stagnant
            current_population_size = POPULATION_SIZE
            if consecutive_same_fitness >= 2:
                current_population_size = POPULATION_SIZE * 10 # Increase population size by double
                tqdm.write(f"Fitness stagnant for {consecutive_same_fitness} generations. Increasing population size to {current_population_size}")


            # ห่อการ print ด้วย progress_bar.write เพื่อไม่ให้ progress bar แสดงผลเพี้ยน
            report_generation_stats(
                best_chromosome_this_gen,
                gen + 1,
                best_fitness_this_gen,
                courses_df,
                instructors_df
            )

            # คัดเลือก (Selection)
            elites = [p[0] for p in population_with_fitness[:ELITE_SIZE]]

            # สร้างประชากรใหม่ด้วย mutation 2 แบบ
            next_population = elites[:]
            while len(next_population) < current_population_size:
                # เลือก operator based on rates
                r = random.random()
                if r < CHANGE_MUTATION_RATE:
                     # Change Mutation
                    parent = random.choice(elites)
                    child = change_mutation(parent, NUM_INSTRUCTORS)
                    next_population.append(child)
                elif r < CHANGE_MUTATION_RATE + SWAP_MUTATION_RATE:
                    # Swap Mutation
                    parent = random.choice(elites)
                    child = swap_mutation(parent)
                    next_population.append(child)
                else:
                    # Crossover
                    if len(elites) >= 2:
                        parent1, parent2 = random.sample(elites, 2)
                        child1, child2 = crossover(parent1, parent2)
                        next_population.append(child1)
                        if len(next_population) < current_population_size:
                             next_population.append(child2)
                    else:
                         # Fallback to mutation if not enough parents for crossover
                         parent = random.choice(elites)
                         if random.random() < 0.5:
                            child = change_mutation(parent, NUM_INSTRUCTORS)
                         else:
                            child = swap_mutation(parent)
                         next_population.append(child)

            population = next_population


    # --- สิ้นสุด GA ---
    print("\nEvolution complete.")

    # จัดเรียงประชากรสุดท้ายเพื่อหาโซลูชันที่ดีที่สุด 5 อันดับแรก
    # Need to calculate fitness for the final population again as the loop finishes the pool
    final_fitness_scores = [calculate_fitness(chrom, courses_df, instructors_df) for chrom in population]
    final_population_with_fitness = sorted(zip(population, final_fitness_scores), key=lambda x: x[1])
    best_solutions = [p[0] for p in final_population_with_fitness[:2]]

    # --- 4. แสดงผลลัพธ์ตารางการจัดสอน ---
    print("\n--- ตารางการจัดสอนสำหรับ 5 โซลูชันที่ดีที่สุด ---")

    original_pref_columns = instructors_df.columns[3:]

    for i, solution in enumerate(best_solutions):
        print(f"\n--- Solution {i+1} (Final Fitness: {final_population_with_fitness[i][1]:.2f}) ---")
        result_df = instructors_df.copy()
        result_df[original_pref_columns] = 0

        for course_idx, instructor_idx in enumerate(solution):
            # Ensure instructor_idx is within the bounds of result_df index and course_id exists as a column
            if instructor_idx < len(result_df) and course_idx < len(courses_df):
                 course_id = courses_df.iloc[course_idx]['courseID']
                 if course_id in result_df.columns:
                    result_df.loc[instructor_idx, course_id] = 1
                 else:
                     tqdm.write(f"Warning: Course ID '{course_id}' not found in result_df columns.")
            else:
                 tqdm.write(f"Warning: Instructor index {instructor_idx} or course index {course_idx} out of bounds when creating result table.")


        print(result_df.to_string())

    print("\n\n--- รายงานสรุปจากโซลูชันที่ดีที่สุดได้แสดงผลใน Generation สุดท้ายแล้ว ---")
    
    
